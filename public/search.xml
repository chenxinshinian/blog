<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>解决博客访问此书不正确问题</title>
      <link href="/2020/05/14/jie-jue-bo-ke-fang-wen-ci-shu-bu-zheng-que-wen-ti/"/>
      <url>/2020/05/14/jie-jue-bo-ke-fang-wen-ci-shu-bu-zheng-que-wen-ti/</url>
      
        <content type="html"><![CDATA[<p><img src="https://chenxinshinian.oss-cn-beijing.aliyuncs.com/img/20200514143133.png"></p><p>一次无意间通过百度搜索自己的博客，点进去后发现博客的访问数量不对,<br>仔细观察发现百度给我快照的是<a href="https://www.chenxinshinian.com" target="_blank" rel="noopener">https://www.chenxinshinian.com</a> 而我平时都是习惯使用 <a href="https://chenxinshinian.com">https://chenxinshinian.com</a><br>这样该是node插件的问题，加上二级域名前缀竟然有两套不同的计算方式..太坑了。。。。<br><img src="https://chenxinshinian.oss-cn-beijing.aliyuncs.com/img/20200514143625.png"><br><img src="https://chenxinshinian.oss-cn-beijing.aliyuncs.com/img/20200514143823.png"></p><p>最后决定用最简单粗暴的方式解决，我直接到阿里云控制台关闭对www二级域名的解析，只保留一个入口，嘿嘿…<br>反正感觉加上个前缀也是多此一举，输入还麻烦，</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> blog </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库设计</title>
      <link href="/2020/05/12/shu-ju-ku-she-ji/"/>
      <url>/2020/05/12/shu-ju-ku-she-ji/</url>
      
        <content type="html"><![CDATA[<p><img src="https://chenxinshinian.oss-cn-beijing.aliyuncs.com/img/d22bbcc815668a3244e4237c1731b98d8ee370a3.jpg"></p><p><a href="https://chenxinshinian.com/2020/05/12/shu-ju-ku-she-ji/">数据库设计</a><br><a href="https://chenxinshinian.com/2020/05/09/shu-ju-ku-luo-ji-she-ji/">数据库逻辑设计</a><br><a href="https://chenxinshinian.com/2020/05/11/shu-ju-ku-wu-li-she-ji/">数据库物理设计</a><br><a href="https://chenxinshinian.com/2020/05/11/shu-ju-ku-wei-hu-he-you-hua/">数据库维护和优化</a></p><h4 id="为什么要进行数据库设计"><a href="#为什么要进行数据库设计" class="headerlink" title="为什么要进行数据库设计"></a>为什么要进行数据库设计</h4><p>谈到数据库设计首先要弄明白什么是“数据库设计”，我们可以打一个不太恰当的比喻:把数据库应用程序的设计看作是在建立一座大厦，那么建立大厦之前通常要对大厦的整体结构进行设计，并且汇聚成图纸然后应对图纸再对大厦进行施工，那么数据库设计的过程就相当于是我们建造大厦的过程。首先我们也要对数据库的整体结构进行图形化的设计，然后再根据图形来对数据库结构进行建立。那么简单来说：<br>数据库设计就是根据业务系统的具体需求结合我们所选的DBMS(数据库管理系统),为这个业务系统构造出最优的数据库存储模型，并建立好数据库中的表结构及表与表之间的关联关系的过程。使之能<strong>有效</strong>的对应系统中的数据进行存储，并可以<strong>高效的</strong>的对已经存储的数据进行访问。</p><p>常用的数据库管理系统有：MySQL、Oracle、SQLServer、Pgsql这些都是目前主流的关系性数据库系统<br>已经现在流行的NoSQL系统：Mongo、Memcache、Redis</p><p>注意，我们要达到的目的是<strong>对数据有效的存储以及高效的访问</strong>。那么应用系统中所产生的数据有多种的存储方式。首先我们可以把所有的数据都存储在同一张表中，虽然说这样达到了存储的目的但是却不一定能达到高效访问的目的。</p><h4 id="好的数据库设计对比糟糕的数据库设计"><a href="#好的数据库设计对比糟糕的数据库设计" class="headerlink" title="好的数据库设计对比糟糕的数据库设计"></a>好的数据库设计对比糟糕的数据库设计</h4><p>一个优良的数据库设计：<br>1)可以减少数据冗余<br>2)避免数据维护异常<br>3)节约存储空间<br>4)高效的访问<br>反之一个糟糕的数据库设计：<br>1)会存在大量数据冗余<br>2)存在数据插入，更新，删除的异常<br>3）浪费大量存储空间<br>4）访问数据低效</p><p>数据库系统是应用系统存储数据的关键组成部分，是系统稳定运行的基础，决定着系统是否可以高效稳定的运行，还以刚才大厦的例子来说，我们的数据库就相当于是这个大厦的地基，如果大厦的地基可以稳固，那么大厦就可以建的很高，如果地基没有建好那么大厦就很容易倒塌，同样如果数据库没有设计好的话那么系统就不会太稳定。这种情况可能在最终我们系统访问量很小数据也不多的情况下不明显，但是随着我们数据库的数据越来越多访问量的越来越大，那么这种数据库设计的缺陷就会显现出来。<br>例如一家初创企业，在初创期开发人员并不多并且也没有在专业的DBA，这样他们所设计的数据库仅仅是以存储数据为目的，达到数据存储后就没有进一步进行调优，这就会使得这家企业业务发展起来的时候，数量非常大的时候就会在一些比较重要的促销时经常会出现系统死机的情况，这不但影响的公司业务的正常运行，并且对今后的开发也在造成的非常大的影响。所以说我们很有必要在系统设计的开始就对数据库进行一个良好的设计，这样不但对系统稳定带来好处，并且对今后的维护开发已经业务运行都有非常大的好处。</p><h4 id="数据库设计步骤"><a href="#数据库设计步骤" class="headerlink" title="数据库设计步骤"></a>数据库设计步骤</h4><p>如果你在工作中要对一些慢查询进行调优工作，但是慢查询是由于数据库结构设计的不合理产生的。那么我们进行慢查询调整的时候就必然要对数据库的结构进行调整，而当我们的数据库已经在生产环境运行了一段时间的话，我们要再想对数据库结构进行调整就必然会影响业务的正常运行，这是谁都不希望看到的，所以我们很有必要在数据库设计的最终就把数据库设计成一个简洁高效的数据库结构。</p><p>数据库设计的步骤：<br><strong>需求分析-&gt;逻辑设计-&gt;物理设计-&gt;维护优化</strong></p><p>和应用程序设计一样，数据库设计最初也要进行需求分析，只不过数据库的需求分析和应用程序的需求分析侧重点不太一样。数据库设计的需求分析的侧重点主要是：<br>应用主要在数据库中存储的数据是什么？而这些数据又有哪些属性？这些数据和属性各自的特点又有那些？</p><p>我们只要了解这些东西，那么就对我们后边的数据库设计有非常大的帮助</p><p>需求分析之后是逻辑设计，在逻辑中我们主要是通过ER图这种工具对数据库进行逻辑建模。这个逻辑建模之所以叫逻辑建模就是因为他跟我们所选的具体的具体数据库管理系统是没有关系的，我们进行逻辑建模之后是可以在大多数数据库管理系统中在进行表结构的设计的。</p><p>逻辑设计后就是物理设计了，在物理设计中我们就要区考虑我们使用的数据库管理系统是什么。因为就目前来说我们常用的数据库管理系统如,MySQL、Oracle、SQLServer、Pgsql这几种数据库系统他们<br>每一种都有自身的特点，而我们为了把数据库管理系统的效率发挥到最高，那么我们在进行物理设计的时候就要充分的考虑到每一种数据库管理系统具体的特点是什么，这个时候在把逻辑设计中所建立的逻辑模型转换为我们需要的物理模型，这样我们就可以达到数据库效率的最优化。</p><p>物理设计之后就是维护和优化，在维护和优化过程中我们要对新的需求进行表结构的建立或者索引的优化在或者是数据量大到一定程度的时候我们可能要考虑表的拆分。但是在维护和优化中有一个非常重要的地方需要在注意，就是说在最初我们应用上线的在最开始我们的数据库设计是非常完美的，非常简洁也非常高效，但是当需求不断的累加，在时候在后面的开发过程中我们就不注意数据库的设计问题，这样随着应用程序上线的时间越来久需求累加越来越多，我们应用数据库结构也会越来越复杂，这些都属于维护优化工作没有做好的原因。所以在维护优化过程中也要注意，当接到新的需求的时候也要通过以上需求分析、逻辑分析、物理设计这几步，完成之后在进行具体的建表工作，在这样可以就可以保证数据库结构永远是最优的。</p><h4 id="为什么要进行需求分析"><a href="#为什么要进行需求分析" class="headerlink" title="为什么要进行需求分析"></a>为什么要进行需求分析</h4><p>实际工作中一些开发人员都是拿到一个需求之后并不会进行需求分析而是直接进行表结构设计。往往这样设计出的数据库并不会在最优化的。所以有必要在数据库之前进行需求分析。</p><p>在需求分析中我们要先搞清楚：</p><p>在这个系统中我们所存储的数据有哪些?<br>这些数据又有什么样的特点？<br>比如说，有些数据是具有时效性的而有些数据是不具有时效性的。对于一些时效性的数据可以采取过期清理或者归档的方式来进行存储。<br>了解数据的生命周期<br>还有一些数据增长很快数据量也很大，但是这些数据并不是核心数据，对于这些数据我们也可以进行分库分表的方式进行存储。在实际工作中一些开发人员希望把一些日志类的数据存到数据库中，以DBA的角度来看这种数据是非常不是和存储在数据库中的，首先是因为这种数据增长量非常大，并且并不属于核心数据，所以对于这种数据如果一定要存储到数据库中，可以在进行数据库存储之前可以先定义好这种数据的归档或者清理规则，这样可以随着数据库上线就可以进行数据的归档和清理，如果当这个表増长的非常大的时候在进行归档和清理的时候一定工作量非常大，并且很有可能影响线上的正常使用。</p><h4 id="在需求分析中要搞清楚的一些问题"><a href="#在需求分析中要搞清楚的一些问题" class="headerlink" title="在需求分析中要搞清楚的一些问题"></a>在需求分析中要搞清楚的一些问题</h4><p>在需求分析中首先要搞清楚要在数据库中存储的对象都有什么?<br>这些对象也可以称之为实体。实体及实体之间的关系？<br>实体和数据库表之间的关系是并不是一一对应的而是可以1对1，1对多，多对多，实体之间的关系也是如此<br>实体所包含的属性有什么?<br>这些属性也有各自的特点，比如说那些属性是可以标识出这些实体的，<br>哪些属性或组合可以唯一标识一个实体？<br>那个标识出实体的属性可能是一个也可能是多个或者是多种组合来标识这个实体。具体选用哪一种是需要我们在逻辑设计中考虑的问题，但是在需求分析的时候我们就要把这些属性和属性组合搞清楚。<br>清楚实体所包含的属性之后还要了解出实体的一些特性，比如在存储上有什么样的特性，增长量会是什么样?就比如对一些日志类的实体<br>可能增长比较快，对于这些实体我们就要考虑分库分表的操作或者是按时进行归档，这些内容是我们要在物理设计中考虑的，但是如果在需求分析中没有把这些搞清楚的话，在在物理设计和逻辑设计中就很难对数据库进行分库分表的设计或者归档的设计</p><h4 id="实例演示"><a href="#实例演示" class="headerlink" title="实例演示"></a>实例演示</h4><p>以一个小型的电子商务网站为例，在这个电子商务网站的系统中包括了几个核心模块：用户模块，商品模块，订单模块，购物车模块，供应商模块。</p><p>用户模块主要用于用户登录和保存用户注册信息<br>包括属性：用户名 、密码、电话、邮箱、身份证号、地址、姓名、昵称……<br>可选唯一标识属性：用户名、身份证、电话<br>存储特点：随着系统上线时间逐渐增加，需要永久存储，这就要求在物理设计中考虑对用户模块是否要分库分表的问题</p><p>商品模块用于记录网站中所销售的商品信息<br>包括属性：商品编码、商品名称、商品描述、商品品类、供应商名称、重量、有效期、价格……<br>可选唯一标识属性：（商品名称、供应商名称）、（商品编码）<br>因为一个供应商可能对我们提供多个商品，同时也有可能一个商品由多个供应商提供,所以商品名称和供应商名称的组合才能唯一标识出哪一个供应商提供的哪一个商品<br>存储特点：随着网站经营时间的增长,商品也会越来越多，但是对于某一个供应商的商品来说，如果这个供应商已经不再对我们提供供应的话，对于这些商品我们实际上可以进行一些归档的存储。但是，切记这些商品是不能删除的，因为有可能还会和订单模块相关,所以这些商品是需要永久存储，但是可以对一些不再销售的商品进行一些迁移工作（先迁移到其他表中）这样对我们商品表可以保持一个比较小的数量级，能对搜索查询的效率带来好处</p><p>订单模块用于存储用户订购商品的信息<br>因为订单是属于用户的所以要包括：订单号、用户姓名、用户电话、收货地址、商品编号、商品名称、数量、价格、订单状态、支付状态、订单类型……<br>可选唯一标识属性：（订单号）（用户命名、商品、下单日期）<br>存储特点：随着经营的增长订单表数据会越来越多，订单表需要永久存储，并且很多用户需要查询历史订单记录，所以订单表的查询频率会非常大，所以要考虑分表或者分库的操作</p><p>购物车模块用于存储用户选购的商品信息<br>包括属性：用户名、商品编号、商品名称、商品价格、商品描述、商品分类、加入时间、商品数量……<br>可选唯一标识：（用户名、商品编号、加入时间）、（购物车编号）<br>存储特点：不用永久存储（设置归档、清理规则），购物车的数据有一定的实效性，比如半年内没有被购买的数据进行一些清理操作</p><p>供应商模块用于保存所销售商品的供应商信息<br>包括属性：供应商编号、供应商名称、联系人、电话、营业执照号、地质、法人……<br>可选唯一标识：（供应商编号）（营业执照号）<br>存储特点：永久存储,供应商的数量不会特别多，所以不需要什么策略”</p><p><img src="https://chenxinshinian.oss-cn-beijing.aliyuncs.com/img/20200509065747.png"></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库设计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库维护和优化</title>
      <link href="/2020/05/11/shu-ju-ku-wei-hu-he-you-hua/"/>
      <url>/2020/05/11/shu-ju-ku-wei-hu-he-you-hua/</url>
      
        <content type="html"><![CDATA[<p><img src="https://chenxinshinian.oss-cn-beijing.aliyuncs.com/img/20200511125758.png"></p><p><a href="https://chenxinshinian.com/2020/05/12/shu-ju-ku-she-ji/">数据库设计</a><br><a href="https://chenxinshinian.com/2020/05/09/shu-ju-ku-luo-ji-she-ji/">数据库逻辑设计</a><br><a href="https://chenxinshinian.com/2020/05/11/shu-ju-ku-wu-li-she-ji/">数据库物理设计</a><br><a href="https://chenxinshinian.com/2020/05/11/shu-ju-ku-wei-hu-he-you-hua/">数据库维护和优化</a></p><p>由于项目中需求是不断变化的，所以数据库中的结构也是需要不断的做相应的改变</p><h4 id="维护和优化中要做什么"><a href="#维护和优化中要做什么" class="headerlink" title="维护和优化中要做什么"></a>维护和优化中要做什么</h4><p>1）维护数据字典</p><p>数据字典对于应用是否便于维护是非常重要的，如果我们不清楚表中每一个列或者说每一个表中存储的内容是什么，那么今后对应用进行升级维护就很难入手。<br>特别是一些状态字段，比如用一些数字来表示的状态值，那么每一个数字代表的含义就一定要记录在数据字典中</p><p>2）维护索引</p><p>由于表结构和数据量的不断变化以及业务上使用的查询的不断变化我们就要对表中的索引去不断的进行维护和优化，有的索引在刚开始可能是适用的，但是随着数据量的增长和查询不断的变化，索引也可能从适用变成了不使用，这时候就要对老的索引进行删除并且建立新的索引</p><p>3）维护表结构</p><p>也是由于需求的不断变化，表结构也会随之跟着改变。如列的增加或者删除或者对于一些列的类型跟着更改</p><p>4）在适当的时候对表进行水平拆分或垂直拆分</p><p>随着数据量的不断增长，表中存储的数据量是有一定的瓶颈的，它超过某一个量级之后查询就会变得非常缓慢，这时就要进行拆分，拆分又分为水平拆分和垂直拆分</p><h4 id="如何维护数据字典"><a href="#如何维护数据字典" class="headerlink" title="如何维护数据字典"></a>如何维护数据字典</h4><p>维护数据字典有很多种方式</p><p>1）使用第三方工具对数据字典进行维护</p><p>不同的数据库管理系统有不同的数据字典工具。</p><p>2）利用数据库本身的备注字段来维护数据字典。以mysql为例<br><img src="https://chenxinshinian.oss-cn-beijing.aliyuncs.com/img/20200511162843.png"><br><img src="https://chenxinshinian.oss-cn-beijing.aliyuncs.com/img/dsadasdasdasdasd.png"></p><p>导出数据库就可以形成数据字典了。</p><h4 id="如何维护索引"><a href="#如何维护索引" class="headerlink" title="如何维护索引"></a>如何维护索引</h4><p>如何选择和是的列建立索引？</p><p>1） 出现在where从句，group by从句，order by从句中的列</p><p>但是从句中经常会出现多个列的情况，这种时候就要选择可选择性高的列要放到索引的前面</p><p>2） 可选择性高的列要放到索引的前面</p><p>这时大家可能会有一个误区：在索引列的顺序上要跟where条件中的列的顺序要保持一致，实际上这个要求并不是必须的，因为在现在的数据库中所有的sql在执行之前都要经过sql<br>优化器重新编译。在编译过程中sql优化器就会按照我们数据库中的索引和统计信息对查询列重新的排序和优化，会自动选择适合sql的索引。</p><p>3） 索引中不要包括太长的数据类型</p><p>数据库是页的形式存储的，页对于mysql来说就是16k，在16k的大小中能够存储的条数越多那么索引查找的速度就会越快，因此索引的列不要太长，例如在mysql中它可以对“前置”进行索引的，比如text类型可以选择对前16个text字节进行索引</p><h4 id="索引维护注意事项"><a href="#索引维护注意事项" class="headerlink" title="索引维护注意事项"></a>索引维护注意事项</h4><p>1）索引并不是越多越好，过多的索引不但会降低写效率，而且会降低读的效率</p><p>2）定期维护索引碎片</p><p>3）在SQL语句中不要使用强制索引关键字</p><h4 id="如何维护表结构"><a href="#如何维护表结构" class="headerlink" title="如何维护表结构"></a>如何维护表结构</h4><p><img src="https://chenxinshinian.oss-cn-beijing.aliyuncs.com/img/20200511172206.png"></p><h4 id="数据库中适合的操作"><a href="#数据库中适合的操作" class="headerlink" title="数据库中适合的操作"></a>数据库中适合的操作</h4><p>如果我们在数据库中只执行它适合的操作的话，那么优化就成功了一大半</p><p>1） 批量操作 VS 逐条操作</p><p>数据库中适合批量操作，而逐条操作适合在程序中完成</p><p>2） 禁止使用 select * 这样的查询</p><p>这样会造成io的浪费，因为查询出大量的我们不使用的字段，另外如果表结构进行了变更使用select * 可能会使程序出错</p><p>3） 控制用户使用自定义函数</p><p>大量使用自定义函数会对索引的使用造成影响，因为如果使用了函数那么列中的索引就会不起作用，所以开发过程中尽量少使用自定义函数</p><p>4）不要使用数据中的全文索引</p><p>因为全文索引是需要另外建立索引文件来进行维护的，另外一方面是对中文的支持也不是太好</p><h4 id="数据库表的垂直和水平拆分"><a href="#数据库表的垂直和水平拆分" class="headerlink" title="数据库表的垂直和水平拆分"></a>数据库表的垂直和水平拆分</h4><p><img src="https://chenxinshinian.oss-cn-beijing.aliyuncs.com/img/20200511173415.png"></p><p>垂直拆分就是把原来的一张表拆分成多张小的表，垂直拆分后的多张小表他们的列是不一样的，这就是表的垂直拆分</p><h4 id="什么时候进行垂直拆分？"><a href="#什么时候进行垂直拆分？" class="headerlink" title="什么时候进行垂直拆分？"></a>什么时候进行垂直拆分？</h4><p>当我们的需求变得越来越多，我们可能会对某一张表的列进行增加，当这张表的列增加到几十列的时候，这个时候我们就要考虑对表进行垂直拆分。</p><h4 id="那么垂直拆分有什么好处呢？"><a href="#那么垂直拆分有什么好处呢？" class="headerlink" title="那么垂直拆分有什么好处呢？"></a>那么垂直拆分有什么好处呢？</h4><p>首先我们数据库是以“页”来进行存储的，页中我们存储的行数越多那么我们的IO效率也就越高，但当一张表变得非常宽的时候，那么也就意味着每一行的数据大小也会变大，这样在一页中所能存储的行数就会越来越少，那么IO效率也会变得很低，但当我们对一张非常宽的表进行垂直拆分后形成多张比较窄的窄表，那么这时候每一张小表中每一行的长度就不会太大，这样就优化了表的IO读取效率。</p><h4 id="把哪些列放到小表中？"><a href="#把哪些列放到小表中？" class="headerlink" title="把哪些列放到小表中？"></a>把哪些列放到小表中？</h4><p>首先要把经常一起查询的列放大一张表中，另外把一些大字段放到另外的表中，这样就在查询的时候不需要在进行表的关联操作了，不但优化了IO，也减少了sql的复杂程度</p><p>但是通过表的垂直拆分之后表的数据量是不应该有变化的，原来大表有一百万条数据，那么拆分后的小表每个也应该有一百万条数据。</p><h4 id="表的水平拆分"><a href="#表的水平拆分" class="headerlink" title="表的水平拆分"></a>表的水平拆分</h4><p>那么如果有一张大表，表中已经有了上亿条数据，我们希望把这张表的数据量减少，比如我们希望每张表中只有一千万行数据，那么这个时候就需要对表进行水平拆分<br><img src="https://chenxinshinian.oss-cn-beijing.aliyuncs.com/img/20200512211357.png"><br>水平拆分后每张表的结构都是相同的，把原来的一张表复制成多份，这就叫做水平拆分，每张表中存储的数据是不一样的。</p><p>如何把一张大表中的数据分散到多个小表中呢？下面说种比较常用的方法：<br><img src="https://chenxinshinian.oss-cn-beijing.aliyuncs.com/img/20200512212010.png"><br>通过主键哈希的方式来进行，每一张表中都是应该有主键的，通过对主键值进行哈希操作，比如说根据主键按模来取值，这样就可以把原来的一张大表平均的分散到多张小表中，每张小表的数据量是非常平均的，因为我们取的是哈希值，但是每张表中存储的数据都是不一样的，只有把这五张表全部汇总起来才是原来一张大表的数据，这就是比较常用的一种水平拆分的方式，水平拆分解决了表中数据量的问题，而垂直拆分解决了表的宽度问题，这就是在维护优化中经常用到的优化方式来优化表的IO</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库设计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库物理设计</title>
      <link href="/2020/05/11/shu-ju-ku-wu-li-she-ji/"/>
      <url>/2020/05/11/shu-ju-ku-wu-li-she-ji/</url>
      
        <content type="html"><![CDATA[<p><a href="https://chenxinshinian.com/2020/05/12/shu-ju-ku-she-ji/">数据库设计</a><br><a href="https://chenxinshinian.com/2020/05/09/shu-ju-ku-luo-ji-she-ji/">数据库逻辑设计</a><br><a href="https://chenxinshinian.com/2020/05/11/shu-ju-ku-wu-li-she-ji/">数据库物理设计</a><br><a href="https://chenxinshinian.com/2020/05/11/shu-ju-ku-wei-hu-he-you-hua/">数据库维护和优化</a></p><h4 id="物理设计要做什么"><a href="#物理设计要做什么" class="headerlink" title="物理设计要做什么"></a>物理设计要做什么</h4><ol><li>选择合适的数据库管理系统</li><li>定义数据库、表及字段的命名规范。</li><li>根据所选的DBMS系统选择合适的字段类型。</li><li>反范式化<br>指的是在逻辑设计中已经确立好的非常规范的数据库结构模型，模型没有任何数据冗余，那么在物理设计中可能会为了读效率的考虑会在表中增加一些冗余来达到效率的提升，换句话说就是用空间换时间<br>选择合适的DBMS系统</li></ol><h4 id="选择合适的DBMS系统"><a href="#选择合适的DBMS系统" class="headerlink" title="选择合适的DBMS系统"></a>选择合适的DBMS系统</h4><p><img src="https://chenxinshinian.oss-cn-beijing.aliyuncs.com/img/20200509140730.png"><br>首先来说要考虑成本问题，对于Oracle和SQLServer来说它是属于商业数据库，这就不得不考虑版权的问题，从SQLServer2012之后就使用了和Oracle相同的基于服务器的核数来进行收费的策略，由于我们目前服务器的核数都比较多，在这种情况下我们使用商业数据库我们的成本是不得不去考虑的一个问题。<br>而MYSQL和PGSQL是常见的开源数据库，而对于开源数据库来说，只要我们在使用的时候是符合开源协议的，那么就不需要支付版权费用。<br>除了版权之外，我们还要对功能进行考虑，对于Oracle来说是属于业界口碑比较好的数据库系统，性能是非常高的，比较适合比较大的事物操作，因为在Oracle中它的事务成本是非常低的。<br>除了功能上我们使用的操作系统上也可以进行选择，像SQRServer数据库因为是微软的产品，所以它是只支持windows上面运行的。而Oracle、MYsql和Pgsql呢是可以同时运行在windows下和linux下的。<br>除了这些我们还要考虑开发使用的语言，如果在开发中使用的是.net这种语言，那么SQLServer对.net配合是更好的选择。<br>之后和还要考虑应用场景，对于目前来说mysql和pgsql这种开源数据库是比较常用于互联网项目，而Oracle和SQLServer更适用于企业级项目，比如说一些金融类的公司可能会更喜欢Oracle，因为它相对来说扩展比较容易，也相对也更加安全。SQLServer更倾向于一些中小企业的企业级数据库，比如说一些ERP系统。</p><h4 id="Mysql常用的存储引擎"><a href="#Mysql常用的存储引擎" class="headerlink" title="Mysql常用的存储引擎"></a>Mysql常用的存储引擎</h4><p>由于MySQL是一种开源型的数据库，所以它的存储也非常开放，只要符合mysql的存储协议，那么任何场上都可以实现自己的存储引擎。</p><p>mysql的常用存储引擎：<br><img src="https://chenxinshinian.oss-cn-beijing.aliyuncs.com/img/20200509143259.png"></p><p>MyISAM是MySQL5.5以前默认使用的存储引擎，这种存储引擎的特点是不支持事务，但是他的读写效率相对来说更高，由于它不支持事务，所以它对一些事务处理上的开销也就更少，这些是它读写比较高效的原因，但是由于它不支持事务，这也面临着它在写的时候要对全表进行加锁，也就是说写并发非常大就有可能造成锁阻塞，所以它的使用场景是如果写很少读很多的时候可以使用这种引擎</p><p>MRG_MyISAMD这种存储引擎是和MyISAM存储引擎有一定的关系的，它是可以把多个结构相同的MyISAM表合并成一个表进行处理，这比较像视图或者分区的一种功能，但是由于是基于MyISAM的所以同样不支持事务，并且不再支持行级锁存储引擎。主要应用于分段归档和数据仓库这种需要把多个表变成一个表进行逻辑处理的可以使用这种存储引擎，因为它的写相对来说是非常少的，可能是基于某一时间去写，但大多数场景都是在读。并且这种存储引擎也不适用于那种全局查找过多的场景，和分区表一样如果全局查找太多就涉及到要在在多个分区中或者表中浸信会个扫描，这样效率会更低，如果全局查找太多也不适用于这种存储引擎</p><p>innodb是mysql5.5之后mysql默认使用的存储引擎，也是目前在大多数互联网应用中建立大家使用的引擎，首先这种引擎支持事务，并且支持多版本并法的行级锁，也就是说比较类似与Oracle这种事务特点，主要应用场景就是需要用到事务处理的场景，并且禁用场景目前没有，也就是大多数场景都可以用innodb引擎，由于是行级锁所以读写也是非常高效的，和MyISAM不同点是它不会有表级锁的存在，基本上都是对于行级锁进行处理，因此阻塞会更少</p><p>Archive的特点是也是行级锁，但是它支持insert和select操作，不支持update操作，这种存储引擎更倾向于日志的这种场景,因为日志只需要添加而并不需要更新，这种时候就可以使用在这种存储引擎，这种存储引擎的特点是它的存储需要的容量相对来说更小，也就是说innodb来进行存储新需要100m，而Archive可能只需要几十m或者十几m空间就能完成相同数量级的存储</p><p>Ndb cluster这种存储引擎是mysql集群所使用的存储引擎，这种存储引擎的特点是，首先支持事务，并且也是行级锁，主要应用场景是要使用mysql集群的情况下使用NDB存储引擎，由于mysql集群是内存型的一种集群，大部分数据要放到内存中，所以在大多数情况下如果我们数据量比较大超过内存的大小，这种情况下就不太适用于NDB集群，也就不可能再使用NDB集群的存储引擎</p><h4 id="数据库表及字段的命名规范"><a href="#数据库表及字段的命名规范" class="headerlink" title="数据库表及字段的命名规范"></a>数据库表及字段的命名规范</h4><p>所有对象命名应该遵循下述规则：<br>1）可读性原则<br>使用大写和小写来格式化的库对象名字以获得良好的可读性。<br>例如：使用CustAddress而不是custaddress来提高可读性。（这里要注意有些DBMS系统对表名的大小写是敏感的）</p><p>2)表意性原则<br>对象的名字应该能够描述它所标识的对象。<br>例如，对于表，表的名称应该能够体现表中存储的数据内容；对于存储过程，存储过程名称应该能够体现存储过程的功能。</p><p>3)长名原则<br>尽可能少使用或者不使用缩写，适用于数据库(DATABASE)名之外的任一对象。</p><h4 id="字段类型的选择原则"><a href="#字段类型的选择原则" class="headerlink" title="字段类型的选择原则"></a>字段类型的选择原则</h4><p><img src="https://chenxinshinian.oss-cn-beijing.aliyuncs.com/img/20200510190125.png"><br>比如生日这个字段至少可以使用四种类型进行存储<br>第一种char类型，1978-03-01大概需要十个字节就够了<br>第二种使用varchar变长字段来进行存储，就varchar存储的好处是可以存1978-03-01 或者 19780301 都是可以的，因为字符串长度不一样所使用的存储空间也是不一样的<br>第三种最常见的是使用日期时间类型来进行存储<br>最后一种是使用unix时间辍来进行存储，unix时间辍是一个整型，数字代表的意思也是978-03-01，它是自1971-01-01 00:00:00 到现在的秒数</p><p>列的数据类型一方面影响数据存储空间的开销，另一方面也会影响数据查询性能。当一个列可以选择多种数据类型时，应该优先考虑数字类型，其次是日期或二进制类型，最后是字符串类型。对于相同级别的数据类型，应该优先选择则占用空间小的数据类型。</p><p>比如上面例子就应该优先选择int类型其次是datetime在其次是char和varchar</p><p>以mysql为例，各数据类型占用的存储空间大小：<br><img src="https://chenxinshinian.oss-cn-beijing.aliyuncs.com/img/20200510191946.png"><br>以上选择原则在主要是从下面两个角度考虑：<br>1） 在对数据进行比较（查询条件、JSON条件及排序）操作时：同样的数据，字符处理往往比数字处理慢。<br>这是因为字符串类型的处理是与我们选择的排序规则有关的，也就是说它要去查询我们当前所使用排序规则的字典顺序来确定字符串的比较和排序顺序，而数字的二进制类型不需要参考这种数据字典，因此在进行数据的排序和比较过程中使用二进制或者int类型的效率要高于字符串类型。</p><p>2）在数据库中，数据处理以页为单位，列的长度越小，利于性能提升。<br>因为不同的关系型数据库页的大小是不一样的，如SQLServer是8k一页，而mysql在innodb中默认是16k字节一页，而列的长度越小，我们在一个页中所能存储的数据量就越多，这样再加载相同的数据的时候如果我们的列越小我们加载的页数越小，这样IO的性能就会提高，现在数据库最大瓶颈并不是CPU，而是磁盘IO瓶颈，也就是说如果我们优化了IO瓶颈就是优化了我们数据库的性能</p><h4 id="char与varchar如何选择"><a href="#char与varchar如何选择" class="headerlink" title="char与varchar如何选择"></a>char与varchar如何选择</h4><p>原则：<br>1)如果列中要存储的数据长度差不多是一致的，则应该考虑用char;否则应该考虑用varchar。</p><p>2）如果列中的最大数据长度小于50Byte，则一般也考虑用char。<br>（当然，如果这个列很少用，则基于节省空间和减少IO的考虑，还是可以选择用varchar）</p><p>3）一般不宜定义大于50Byte的char类型列。</p><p>例如身份证号或者说电话这种字符串，它的长度基本上都是一致的，那么这个时候就可以选择char来进行存储，而不是varchar。如果内容最大的数据长度小于50个字节也一般可以使用char来存储，因为每一个varchar的列除了存储数据所需要的数据长度之外还需要额外的在字节来存储变长数据的字典，而在检索数据的时候也要确定数据存取的起始位置，所以长度太小就不适合用varchar来进行存储。<br>如果我们所存储的这个数据是大于50个字节的那么就最好使用varchar，在mysql中不同的字符编码占用的字节是不一样的，比如UTF-8每个字符占用三个字节，也就是说50/3，也就是字符串大于15个字符就要考虑使用varchar而不是char</p><h4 id="decimal和float如何选择"><a href="#decimal和float如何选择" class="headerlink" title="decimal和float如何选择"></a>decimal和float如何选择</h4><p>原则：</p><p>1) decimal用于存储精确数据，而float只能用于存储非精准数据。故精确数据只能选择decimal类型。</p><p>2) 由于float的存储空间开销一般比decimal小（精确到7位小数只需要4个字节，而精确到15位小数只需要8字节）故非精确数据优先选择float类型</p><h4 id="时间类型如何存储"><a href="#时间类型如何存储" class="headerlink" title="时间类型如何存储"></a>时间类型如何存储</h4><p>1）使用int类存储时间字段的优缺点<br>优点：字段长度比datetime小<br>缺点：使用不方便，要进行函数转换。<br>限制：只能存储2038-1-19 11：14：07及2^32为2147483648</p><p>如果存储订单的日期那么最好使用datetime，因为要时常要进行时间范围判断查询来判断订单是否到期</p><p>2）需要存储的时间粒度<br>年 月 日 小时 分 秒 周</p><p>比如之存储到年那么可以用year，year之战用一个字节</p><p>如何选择主键<br>1）区分业务主键和数据库主键<br>业务主键用于标识业务数据，进行表与表之间的关联；<br>数据库主键为了优化数据库存储（innodb会生成6个字节的隐含主键）</p><p>一些情况下业务主键和数据库主键是相同的，但是在一些情况下业务主键和数据库主键又是不同的，为什么要定义主键呢？因为在一些数据库的表中，比如innodb是要求每个表中必须要有一个主键的，因为它是按照主键的顺序进行逻辑存储的，如果没有主键的话innodb会优先选择具有所有非空列的唯一索引来进行主键，因为没有定义主键唯一索引的话innodb会生成6个字节的隐含列来作为主键，所以使用innodb的话最好人为的去定义一些主键，而不要使用隐含的主键</p><p>2）根据数据库的类型，考虑主键是否要顺序增长<br>有些数据库是按主键的顺序逻辑存储的</p><p>因为innodb是按照主键的逻辑来进行存储，那么最好是需要主键是可以顺序增长的，这样的话它就不会进行数据的逻辑迁移，对我们的IO很有好处，</p><p>3）主键的字段类型所占空间要尽可能的小<br>对于使用聚集索引方式存储的表，每个索引后都会附加主键信息。</p><p>另外因为数据库都是按页来存储数据的，那么主键也要尽可能的小，因为主键越小页中所存储的主键的数量就越多，这样在查询的时候就会装载更少的数据，这样也能对IO性能带来一些好处</p><h4 id="避免使用外键约束"><a href="#避免使用外键约束" class="headerlink" title="避免使用外键约束"></a>避免使用外键约束</h4><p>1）降低数据导入的效率</p><p>2）增加维护的成本</p><p>3）虽然不建议使用外键约束，但是相关联的列上一定要建立索引</p><p>有时经常会听到说外键是用来保持数据完整性的一种方式，但是在这种高并法的互联网网站中如果使用外键会给我们带来一些负面的影响。首先对于数据的写入操作的时候，如果我们使用了外键，那么每写入一条数据都会去查询是否符合外键约束，如果符合才能插入进数据如果不符合就会被拒绝掉，那么检查这个外键约束是否符合的过程是十分的耗时的，可能一般情况下感觉不到，但是在高并法的情况下我们就能深有体会。所以一般建议上在高并法的互联网企业最好不要使用外键约束来进行数据库一致性的保证。但是不使用外键并不意味着我们并不会在外键上建立索引，因为所谓的外键约束它是一种约束，而索引是为了提高查询效率而存在的，就是如果我们进行表关联，这样虽然我们没有建立外键约束，但是我们同样要在关联键上建立索引。</p><h4 id="避免使用触发器"><a href="#避免使用触发器" class="headerlink" title="避免使用触发器"></a>避免使用触发器</h4><p>1）降低数据导入的效率。</p><p>2）可能会出现意想不到的数据异样。</p><p>3）使用业务逻辑变得复杂。</p><h4 id="关于预留字段"><a href="#关于预留字段" class="headerlink" title="关于预留字段"></a>关于预留字段</h4><p>1） 无法准确的知道预留字段的类型。</p><p>2） 无法准确的知道预留字段中所存储的内容。</p><p>3） 后期维护预留字段所要的成本，同增加一个字段所需要的成本是相同的。</p><p>4） 严禁使用预留字段。</p><p>预留字段时你不可能具体字段的类型，并且字段名不会见名思意特别准确，另外后期给列重命名，对于数据库来说就是等于新建了一个列</p><h4 id="什么是反范式化"><a href="#什么是反范式化" class="headerlink" title="什么是反范式化"></a>什么是反范式化</h4><p>反范式化是针对范式化而言的，在在前面介绍了数据库设计的第三范式，所谓的反范式化就是为了性能和读取效率的考虑而适当的对第三范式的要求进行违反，而允许存在少量的数据冗余，换句话说反范式化就是使用空间来换取时间。</p><p>例子：</p><p>符合范式化的设计：<br><img src="https://chenxinshinian.oss-cn-beijing.aliyuncs.com/img/20200510214209.png"><br>如果要查询订单信息：<br><img src="https://chenxinshinian.oss-cn-beijing.aliyuncs.com/img/20200510214332.png"><br>这条sql关联了三张表并且还进行了sum操作才汇总出各项订单信息。<br>可以看出表关联还是非常多的，并且进行了汇总操作所以效率也不会太高</p><p>如果要查出订单详情:<br><img src="https://chenxinshinian.oss-cn-beijing.aliyuncs.com/img/20200511124001.png"><br>反范式化操作：<br><img src="https://chenxinshinian.oss-cn-beijing.aliyuncs.com/img/20200511124059.png"><br>这样虽然增加了一部分冗余数据但是查询变得更加简单明了并且查询效率更高,只需要订单表和商品表就能查出原来需要四张表的订单详情<br><img src="https://chenxinshinian.oss-cn-beijing.aliyuncs.com/img/20200511124239.png"><br>如果要查询订单信息就更简单了：<br><img src="https://chenxinshinian.oss-cn-beijing.aliyuncs.com/img/20200511124536.png"><br>在写入的时候多占用了一些空间，但是在读取的时候可以提效率。在互联网项目中读写比例一般是三比一或者四比一的关系，所以读远远高于写，所以如果写的时候增加了一些数据冗余但是能大大提高读的效率的话还是比较化算的</p><h4 id="为什么反范式化"><a href="#为什么反范式化" class="headerlink" title="为什么反范式化"></a>为什么反范式化</h4><p>1）减少表的关联数量<br>2）增加数据的读取效率<br>3）反范式化一定要适度</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库设计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库逻辑设计</title>
      <link href="/2020/05/09/shu-ju-ku-luo-ji-she-ji/"/>
      <url>/2020/05/09/shu-ju-ku-luo-ji-she-ji/</url>
      
        <content type="html"><![CDATA[<p><img src="https://chenxinshinian.oss-cn-beijing.aliyuncs.com/img/20200509071618.png"></p><p><a href="https://chenxinshinian.com/2020/05/12/shu-ju-ku-she-ji/">数据库设计</a><br><a href="https://chenxinshinian.com/2020/05/09/shu-ju-ku-luo-ji-she-ji/">数据库逻辑设计</a><br><a href="https://chenxinshinian.com/2020/05/11/shu-ju-ku-wu-li-she-ji/">数据库物理设计</a><br><a href="https://chenxinshinian.com/2020/05/11/shu-ju-ku-wei-hu-he-you-hua/">数据库维护和优化</a></p><h4 id="逻辑设计是做什么的"><a href="#逻辑设计是做什么的" class="headerlink" title="逻辑设计是做什么的"></a>逻辑设计是做什么的</h4><ol><li><p>将需求转化为数据库的逻辑模型</p></li><li><p>通过ER图的形式对逻辑模型进行展示</p></li><li><p>同所选用的具体的DBMS系统无关</p></li></ol><p>所谓的逻辑设计就是根据需求分析之所了解到的应用中所需要存储的数据类型来建立数据库的逻辑模型的这么一个过程。所谓的逻辑模型是在任何数据库管理系统中都是通用的。</p><p>ER图就是实体关系模型<br>ER图中的概念：<br>关系：一个关系对应通常所说的一张表。<br>元组：表中的一行即为一个元组。<br>属性：表中的一列即为一个属性；每一个属性都有一个名称，称为属性名。<br>候选码：表中的某个属性组，他可以唯一确定一个元组。<br>主码：一个关系有多个候选码，选定其中一个为主码。<br>域：属性的取值范围。<br>分量：元组中的一个属性值。</p><p><img src="https://chenxinshinian.oss-cn-beijing.aliyuncs.com/img/20200509080751.png"><br><img src="https://chenxinshinian.oss-cn-beijing.aliyuncs.com/img/20200509080704.png"></p><h4 id="逻辑设计规范"><a href="#逻辑设计规范" class="headerlink" title="逻辑设计规范"></a>逻辑设计规范</h4><p>由于在逻辑设计中对同一个实体的存储方式可以有多种不同的设计，比如用户和购物车在这个实体，我们可以把购物车和用户信息存储在统一张表中，也可以分开去存储。这两种存储方式哪种更好一些，就要通过数据库设计的一些规范去进行选择，这也是数据设计的范式<br><img src="https://chenxinshinian.oss-cn-beijing.aliyuncs.com/img/20200509094003.png"></p><h4 id="数据库设计范式"><a href="#数据库设计范式" class="headerlink" title="数据库设计范式"></a>数据库设计范式</h4><p>如果我们符合这些范式的数据库设计就可以设计出简洁高效且结构清晰的数据库设计，同时可以避免数据库的插入更新和删除异常，也可以最大限度的避免数据库的冗余。同样如果比符合这种规范式的设计，那么可能就会存在数据的更新插入的异常，也可能会存在大量的数据冗余，这样就对数据库的使用造成很大的不便。</p><p>常见的数据库设计范式包括：<br>第一范式，第二范式，第三范式及BC范式。当然还是第四及第五范式不过这里我们会把重点放到前三个范式上，这也是目前我们大多数数据库设计所要遵循的范式。</p><h4 id="数据操作异常及数据冗余"><a href="#数据操作异常及数据冗余" class="headerlink" title="数据操作异常及数据冗余"></a>数据操作异常及数据冗余</h4><p><img src="https://chenxinshinian.oss-cn-beijing.aliyuncs.com/img/20200509095904.png"><br>可以看出如果一个表存在插入异常，那么必定也会存在删除异常和更新异常</p><p>数据冗余：是指相同的数据在多个地方存在，或者说表中的某个列可以由其他列计算得到，这样就说表中存在着数据冗余。</p><p>如果数据库设计中存在大量的操作异常和数据冗余那么我们这个设计就是不符合数据库范式要求的，同时在使用中会给我们数据库的使用造成很大的不便，比如我们在插入和更新的时候可能会更新到其他并不应该更新的或者并不该删除的数据，而数据存在大量冗余会对我们数据一致性的维护造成很大的不便，有时候会漏掉某一个表的维护的话，那么就会造成数据一致性的异常。</p><h4 id="第一范式"><a href="#第一范式" class="headerlink" title="第一范式"></a>第一范式</h4><p>第一范式是在所有数据库范式中最简单的一种范式，也就是说我们最容易遵守的一种范式。</p><p><img src="https://chenxinshinian.oss-cn-beijing.aliyuncs.com/img/20200509101147.png"><br>单一属性是指基本的数据类型所构成的，如整型、浮点型、字符串等等。</p><p>二维表指的是都是由行和列组成的表</p><p>在大多数数据库管理系统中都是不可能创建出第二个表这种结构的,这样的结构不符合数据库设计第一范式<br><img src="https://chenxinshinian.oss-cn-beijing.aliyuncs.com/img/20200509101811.png"></p><h4 id="第二范式"><a href="#第二范式" class="headerlink" title="第二范式"></a>第二范式</h4><p><img src="https://chenxinshinian.oss-cn-beijing.aliyuncs.com/img/20200509102105.png"><br>部分函数依赖指的是如果表中的关键字是组合关键字，是由两个或者两个以上的字段来标识这一行数据的，那么这个关键字就称之为组合关键字。而如果非关键字段对这个组合关键字中的某一个字段存在依赖关系这就称之为部分函数依赖。换句话说，如果这个表中是单关键字的那么他就是一定符合第二范式要求的。</p><p>下面看一个例子：<br><img src="https://chenxinshinian.oss-cn-beijing.aliyuncs.com/img/20200509103130.png"><br>这样不符合第二范式的设计会出现下面问题：<br><img src="https://chenxinshinian.oss-cn-beijing.aliyuncs.com/img/20200509103603.png"><br>如何解决这种问题，我们要对不符合第二范式的表进行拆分:<br><img src="https://chenxinshinian.oss-cn-beijing.aliyuncs.com/img/20200509104236.png"></p><h4 id="第三范式"><a href="#第三范式" class="headerlink" title="第三范式"></a>第三范式</h4><p><img src="https://chenxinshinian.oss-cn-beijing.aliyuncs.com/img/20200509110840.png"></p><p>例子：<br><img src="https://chenxinshinian.oss-cn-beijing.aliyuncs.com/img/20200509111400.png"><br><img src="https://chenxinshinian.oss-cn-beijing.aliyuncs.com/img/20200509111318.png"><br><img src="https://chenxinshinian.oss-cn-beijing.aliyuncs.com/img/20200509111749.png"></p><h4 id="BC范式"><a href="#BC范式" class="headerlink" title="BC范式"></a>BC范式</h4><p>BC范式是对第三范式的扩展<br><img src="https://chenxinshinian.oss-cn-beijing.aliyuncs.com/img/20200509112201.png"><br><img src="https://chenxinshinian.oss-cn-beijing.aliyuncs.com/img/20200509112741.png"></p><p>例如表可以根据供应商和商品id为在组合关键字来唯一标识表中的每一行记录，同时可以以供应商联系人和商品id来唯一标识一行记录。<br>这两种标识方式的依赖关系是供应商和商品id决定了联系人和商品数量。<br>联系人和商品id可以决定供应商和商品数量。所以有两种组合关键字的选择。<br>这两组组合关键字又存在这样的关系：</p><p><img src="https://chenxinshinian.oss-cn-beijing.aliyuncs.com/img/20200509112823.png"><br>供应商决定了供应商联系人<br>供应商联系人也可以决定供应商，因为一个供应商联系人之可以受雇于一家供应商，所以存在了这种相互依赖的关系，因此不符合BC范式<br>改进：<br><img src="https://chenxinshinian.oss-cn-beijing.aliyuncs.com/img/20200509113018.png"></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库设计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>单例设计模式</title>
      <link href="/2020/04/19/dan-li-she-ji-mo-shi/"/>
      <url>/2020/04/19/dan-li-she-ji-mo-shi/</url>
      
        <content type="html"><![CDATA[<img src="https://chenxinshinian.oss-cn-beijing.aliyuncs.com/tupian20200123/20200419192343.png"><p><strong>单例模式定义</strong><br>保证一个类只有一个实例, 并且提供一个全局访问点</p><p><strong>什么样的场景下需要使用单例?</strong><br>重量级的对象, 不需要多个实例.<br>如线程池, 或者数据库的连接池. 我们希望我们直接从连接池里面拿连接就可以了, 而不是每次请求都去创建一个对应的连接池</p><h3 id="单例模式的具体实现"><a href="#单例模式的具体实现" class="headerlink" title="单例模式的具体实现"></a>单例模式的具体实现</h3><h4 id="懒汉模式"><a href="#懒汉模式" class="headerlink" title="懒汉模式"></a>懒汉模式</h4><p><strong>特点:</strong> 延迟加载, 只有在真正使用的时候才开始实例化.</p><p><strong>代码:</strong></p><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> com<span class="token punctuation">.</span>company<span class="token punctuation">.</span>shejimoshi<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** * @author chenxinshinian.com * @date 2020/4/19 19:38 */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">LazySingletonTest</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        LazySingletion instance <span class="token operator">=</span> LazySingletion<span class="token punctuation">.</span><span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        LazySingletion instance1 <span class="token operator">=</span> LazySingletion<span class="token punctuation">.</span><span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>instance <span class="token operator">==</span> instance1<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// true</span>    <span class="token punctuation">}</span><span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">LazySingletion</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * 首先提供一个静态的私有属性     */</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> LazySingletion instance<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**     * 提供一个私有的构造函数, 避免直接从外部对对应实例的创建     */</span>    <span class="token keyword">private</span> <span class="token function">LazySingletion</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 提供一个全局的访问点     * @return     */</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> LazySingletion <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">/**         * 在调用getInstance的时候在对他进行实例化         */</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>instance <span class="token operator">==</span> null<span class="token punctuation">)</span><span class="token punctuation">{</span>            instance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LazySingletion</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> instance<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>单例模式在单线程的环境下这样是OK的, 下面试一下两个线程:</p><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> com<span class="token punctuation">.</span>company<span class="token punctuation">.</span>shejimoshi<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** * @author chenxinshinian.com * @date 2020/4/19 19:38 */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">LazySingletonTest</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">></span><span class="token punctuation">{</span>            LazySingletion instance <span class="token operator">=</span> LazySingletion<span class="token punctuation">.</span><span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>instance<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">></span><span class="token punctuation">{</span>            LazySingletion instance <span class="token operator">=</span> LazySingletion<span class="token punctuation">.</span><span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>instance<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">LazySingletion</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * 首先提供一个静态的私有属性     */</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> LazySingletion instance<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**     * 提供一个私有的构造函数, 避免直接从外部对对应实例的创建     */</span>    <span class="token keyword">private</span> <span class="token function">LazySingletion</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 提供一个全局的访问点     * @return     */</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> LazySingletion <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">/**         * 在调用getInstance的时候在对他进行实例化         */</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>instance <span class="token operator">==</span> null<span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">try</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">/**                 * 避免一个线程提前完成, 让线程sleep 2000毫秒                 */</span>                Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">2000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            instance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LazySingletion</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> instance<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p><strong>输出:</strong></p><pre><code>com.company.shejimoshi.LazySingletonTest$LazySingletion@3354d998com.company.shejimoshi.LazySingletonTest$LazySingletion@7245297c</code></pre><p>这个情况说明在多线程的情况下访问这个代码是会出现多线程问题的<br><img src="https://chenxinshinian.oss-cn-beijing.aliyuncs.com/tupian20200123/20200419200000.png"><br>两个线程同时都走到了这个代码块, 两个线程都会进行对应实例的创建, 这样就产生了两个对应的实例, 违背了单例模式的定义</p><p><strong>解决方法:</strong><br>给访问点加上synchronized<br><img src="https://chenxinshinian.oss-cn-beijing.aliyuncs.com/tupian20200123/20200419200355.png"></p><p><strong>输出:</strong></p><pre><code>com.company.shejimoshi.LazySingletonTest$LazySingletion@632a10eacom.company.shejimoshi.LazySingletonTest$LazySingletion@632a10ea</code></pre><p>通过给getInstance加锁的方式确保了单例, 这样会有一定的性能损耗</p><p>优化方案</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/**     * 提供一个全局的访问点     * @return     */</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> LazySingletion <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">/**         * 在调用getInstance的时候在对他进行实例化         */</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>instance <span class="token operator">==</span> null<span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>LazySingletion<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>instance <span class="token operator">==</span> null<span class="token punctuation">)</span><span class="token punctuation">{</span>                    instance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LazySingletion</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> instance<span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><p>这样就能给锁进行一个很大的性能提升, 如果第一个线程就完成它的实例化的话, 那其他线程就不会在对他进行加锁了</p><h4 id="饿汉模式"><a href="#饿汉模式" class="headerlink" title="饿汉模式"></a>饿汉模式</h4><p>类加载的初始化阶段就完成了势力的初始化. 本质上就是借助于JVM类加载及政治, 保证实例的唯一性. </p><p>类加载过程:</p><ol><li>加载二进制数到内存中, 生成对应的Class数据结构.</li><li>连接: a.验证 b.准备(给类的静态成员变量赋<font color="red">默认值</font>), c.解析</li><li><font color="red">初始化</font>:给类的静态变量赋<font color="red">初始值</font></li></ol><p>只有在真正使用对应的类时, 才会触发初始化 如(当前类时启动类即main函数所在类, 直接进行new操作, 访问静态属性 访问静态方法 用反射访问类, 初始化一个类的子类等.)</p><p>代码:</p><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> com<span class="token punctuation">.</span>company<span class="token punctuation">.</span>shejimoshi<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** * @author chenxinshinian.com * @date 2020/4/19 22:44 */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">HungrySingletonTest</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        HungryStingleton instancel <span class="token operator">=</span> HungryStingleton<span class="token punctuation">.</span><span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        HungryStingleton instancel1 <span class="token operator">=</span> HungryStingleton<span class="token punctuation">.</span><span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>instancel <span class="token operator">==</span> instancel1<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// true</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/** * 单例模式-饿汉模式 */</span><span class="token keyword">class</span> <span class="token class-name">HungryStingleton</span><span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> HungryStingleton instance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HungryStingleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token function">HungryStingleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> HungryStingleton <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> instance<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h4 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h4><p>代码:</p><pre class=" language-java"><code class="language-java"><span class="token keyword">import</span> com<span class="token punctuation">.</span>sun<span class="token punctuation">.</span>org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>bcel<span class="token punctuation">.</span>internal<span class="token punctuation">.</span>classfile<span class="token punctuation">.</span>InnerClass<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** * @author chenxinshinian.com * @date 2020/4/19 23:04 */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">InnerClassSingletonTest</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        InnerClassSingleton instance <span class="token operator">=</span> InnerClassSingleton<span class="token punctuation">.</span><span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        InnerClassSingleton instance1 <span class="token operator">=</span> InnerClassSingleton<span class="token punctuation">.</span><span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>instance <span class="token operator">==</span> instance1<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// true</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/** * 静态内部类 本质上也是基于JVM的类加载机制来实现的 而且是一种懒加载的方式 */</span><span class="token keyword">class</span> <span class="token class-name">InnerClassSingleton</span><span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">InnerClassHolder</span><span class="token punctuation">{</span>        <span class="token keyword">private</span> <span class="token keyword">static</span> InnerClassSingleton instance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">InnerClassSingleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token function">InnerClassSingleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> InnerClassSingleton <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> InnerClassHolder<span class="token punctuation">.</span>instance<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><ol><li>静态内部类本质上是利用类的加载机制来保证线程安全</li><li>只有在实际使用的时候, 才会触发类的初始化, 所以也是懒加载的一种形式</li></ol><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 技术总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于本博客</title>
      <link href="/2020/04/03/guan-yu-ben-bo-ke/"/>
      <url>/2020/04/03/guan-yu-ben-bo-ke/</url>
      
        <content type="html"><![CDATA[<img src="https://chenxinshinian.oss-cn-beijing.aliyuncs.com/tupian20200123/v2-73b8307b2db44c617f4e8515ce67dd39_hd.jpg"><p>本博客是基于<a href="https://hexo.io/zh-cn/" target="_blank" rel="noopener">hexo</a>搭建的纯静态博客,采用<a href="https://github.com/blinkfox/hexo-theme-matery" target="_blank" rel="noopener">matery</a>主题,也可以选择其他的主题,如其他优秀的主题有<a href="https://github.com/theme-next/hexo-theme-next" target="_blank" rel="noopener">next</a>,使用markdown编写文章,再通过hexo博客框架编译成静态文件,我这里租用的是阿里云的服务器和域名,写完文章直接编译成静态文件再通过文件传输工具上传到阿里云服务器使用nginx做请求和响应.域名绑定服务器后需要备案才能正常访问,不同地区备案需要的时间有些许差异,我在北京地区备案花的时间是十四天,当然你如果觉得麻烦也可以选择托管在GitHub上,github提供了一个叫做github pages的功能.</p><p>快速搭建一个个人网站的方法有很多,你也可以使用<a href="https://zh-cn.wordpress.com/" target="_blank" rel="noopener">wordpress</a>来搭建自己的网站(在阿里云购买应用服务器就可以预装此软件),这种方法搭建的网站不能部署到github上</p><p>或者你可以使用<a href="https://vuepress.vuejs.org/zh/" target="_blank" rel="noopener">vuepress</a>来做一个自己的个人博客,详细细节点<a href="https://chenxinshinian.com/2020/01/27/da-jian-yi-ge-ji-jian-jing-tai-wang-zhan/">这里</a>,这种方法可以部署到github上</p><p>如果自己有时间也可以自己开发一套,样式 类型 风格全凭自己喜好</p><p>搭建自己的博客很简单,根据上面的一些关键字你就可以搜到很多教程,本文就不写具体细节了.</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> blog </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>免费科学上网</title>
      <link href="/2020/03/02/mian-fei-ke-xue-shang-wang/"/>
      <url>/2020/03/02/mian-fei-ke-xue-shang-wang/</url>
      
        <content type="html"><![CDATA[<img src="https://chenxinshinian.oss-cn-beijing.aliyuncs.com/tupian20200123/20200302071541.png"><p>—-(编辑于2020/4/7)开始—-</p><p><strong>这三款目前我是用的是第三款, 剩下两款是备用的. 不上外网的时候记得关掉插件, 不然访问内网也会变慢</strong></p><p>这三款插件我不敢保证能长期使用并且一直稳定, 不过你能上第一次外网, 那么就可以一直上外网(你可以去油管之类的网站找更好更稳定的科学上网方法, 这些正在内网大多都是被屏蔽的)</p><p>我是觉得作为一个程序员还上不了外网多少有点说不过去, 好的信息资源都是在国外的, 那里是信息的源头, 在国内看到的大多资料都是也都是那些人从信息源头收集在消化后的”残渣”, 所以到信息的源头去, 看第一手资料</p><p>—-(编辑于2020/4/7)结束—-</p><p><strong>1clickVPN</strong></p><p>在chrome网上应用店直接搜索<code>1clickVPN</code> 点击添加至chrome就可安装完成</p><img src="https://chenxinshinian.oss-cn-beijing.aliyuncs.com/tupian20200123/20200308120421.png"><p>上不了谷歌商店也没关系,下面网盘下载链接:</p><p>链接：<a href="https://pan.baidu.com/s/18dB5QrdsFNIp38FyWWkUWg" target="_blank" rel="noopener">https://pan.baidu.com/s/18dB5QrdsFNIp38FyWWkUWg</a><br>提取码：dj2w</p><p>下载后解压后:<br><img src="https://chenxinshinian.oss-cn-beijing.aliyuncs.com/tupian20200123/20200308121345.png"><br>一个crx包,一个已解压的扩展程序</p><p>打开你的谷歌浏览器<br>点击设置—&gt;更多工具—&gt;扩展程序<br><img src="https://chenxinshinian.oss-cn-beijing.aliyuncs.com/tupian20200123/20200308121908.png"></p><p><font color="red">注意:一定要勾选开发者模式</font></p><p>然后点击加载已解压的扩展程序<br><img src="https://chenxinshinian.oss-cn-beijing.aliyuncs.com/tupian20200123/20200308122045.png"><br>选中这一级目录点击选择文件夹</p><img src="https://chenxinshinian.oss-cn-beijing.aliyuncs.com/tupian20200123/20200308122150.png"><p>OK 安装完成</p><p>如果是360浏览器或QQ浏览器安装就更方便了,直接把crx包拖拽的浏览器就行了</p><p>点击右上角小图标,选择你想要的节点<br><img src="https://chenxinshinian.oss-cn-beijing.aliyuncs.com/tupian20200123/20200308122225.png"></p><img src="https://chenxinshinian.oss-cn-beijing.aliyuncs.com/tupian20200123/20200308122304.png">我这里选择了US节点<p>打开youtube访问一下<br><img src="https://chenxinshinian.oss-cn-beijing.aliyuncs.com/tupian20200123/20200308122926.png"></p><p>访问成功</p><font color="red">提示:因为是免费的插件,网速方面不是特别的快,但是上谷歌商店下载一些插件,在外网浏览浏览文章还是没问题的.至于看视频嘛.那就要看脸了...</font><h4 id="更新于-2020-4-7"><a href="#更新于-2020-4-7" class="headerlink" title="更新于 2020/4/7"></a>更新于 2020/4/7</h4><p>之前推荐了一款科学上网的谷歌插件,但是速度较慢,无法流畅的观看外网视频</p><p>这次再推荐两款,我个人觉得准备三个插件够用了</p><p><strong>AdGuard VPN</strong><br>需要邮箱注册,但是无需验证</p><p>链接：<a href="https://pan.baidu.com/s/11t8JrFBEX5gq1KvRjvDNxg" target="_blank" rel="noopener">https://pan.baidu.com/s/11t8JrFBEX5gq1KvRjvDNxg</a><br>提取码：thqw</p><p>安装方式同上</p><p><strong>Astar VPN</strong></p><p>不需要注册,直接使用,有多个节点可供选择</p><p>链接：<a href="https://pan.baidu.com/s/1UrtwhJWkBBWaGZsRpt-2FQ" target="_blank" rel="noopener">https://pan.baidu.com/s/1UrtwhJWkBBWaGZsRpt-2FQ</a><br>提取码：w73m </p><p>安装方式同上</p><p>我个人使用第三个插件比较多,一般在油管看看视频没问题</p><img src="https://chenxinshinian.oss-cn-beijing.aliyuncs.com/tupian20200123/20200407150551.png"><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 分享 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>搭建一个极简静态网站</title>
      <link href="/2020/01/27/da-jian-yi-ge-ji-jian-jing-tai-wang-zhan/"/>
      <url>/2020/01/27/da-jian-yi-ge-ji-jian-jing-tai-wang-zhan/</url>
      
        <content type="html"><![CDATA[<p><img src="https://chenxinshinian.oss-cn-beijing.aliyuncs.com/tupian20200123/20200127190020.png" alt=""></p><p>基于vuepress搭建一个属于自己的极简静态网站，可以作为自己的博客、线上笔记文档等<br><a href="https://chenxinshinian.github.io/" target="_blank" rel="noopener">成品展示</a></p><p><a href="https://vuepress.vuejs.org/zh/" target="_blank" rel="noopener">vuepress官网</a></p><h3 id="需要的软件"><a href="#需要的软件" class="headerlink" title="需要的软件"></a>需要的软件</h3><p>开始前你需要确保自己的电脑上已经安装了<a href="https://git-scm.com/" target="_blank" rel="noopener">Git</a>和<a href="https://nodejs.org/zh-cn/" target="_blank" rel="noopener">Node.js</a></p><p><font color="red">注意：请确保你的 Node.js 版本 &gt;= 8.6。</font></p><h3 id="正式开始"><a href="#正式开始" class="headerlink" title="正式开始"></a>正式开始</h3><h4 id="安装vuepress"><a href="#安装vuepress" class="headerlink" title="安装vuepress"></a>安装vuepress</h4><p>在你的磁盘<font color="red">根目录</font>创建一个文件夹用来存放你的静态网站<br>如：<br><img src="https://chenxinshinian.oss-cn-beijing.aliyuncs.com/tupian20200123/20200127193541.png" alt=""></p><p>进入你创建的文件夹，鼠标右键选择git的命令窗口<br><img src="https://chenxinshinian.oss-cn-beijing.aliyuncs.com/tupian20200123/20200127194228.png" alt=""></p><p>输入全局安装命令</p><pre class=" language-bash"><code class="language-bash"><span class="token function">npm</span> <span class="token function">install</span> -g vuepress</code></pre><p><img src="https://chenxinshinian.oss-cn-beijing.aliyuncs.com/tupian20200123/20200127194600.png" alt=""><br>输入后回车等待安装完成</p><h4 id="验证vuepress"><a href="#验证vuepress" class="headerlink" title="验证vuepress"></a>验证vuepress</h4><p>在git命令窗口输入</p><pre class=" language-bash"><code class="language-bash">vuepress</code></pre><p>如果出现以下内容说明你安装成功了O(∩_∩)O<br><img src="https://chenxinshinian.oss-cn-beijing.aliyuncs.com/tupian20200123/20200127194810.png" alt=""></p><h3 id="创建网站首页"><a href="#创建网站首页" class="headerlink" title="创建网站首页"></a>创建网站首页</h3><p>在根目录打开git命令窗口<br>执行</p><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 新建一个docs文件夹</span><span class="token function">mkdir</span> docs<span class="token comment" spellcheck="true"># 进入docs文件夹目录</span><span class="token function">cd</span> docs/<span class="token comment" spellcheck="true"># 新建一个 markdown 文件</span><span class="token keyword">echo</span> <span class="token string">'# Hello VuePress!'</span> <span class="token operator">></span> README.md</code></pre><p><img src="https://chenxinshinian.oss-cn-beijing.aliyuncs.com/tupian20200123/20200127200935.png" alt=""></p><p>打开README.md文件夹（我这里用的是VSCode），可以看到Hello VuePress!<br><img src="https://chenxinshinian.oss-cn-beijing.aliyuncs.com/tupian20200123/20200127201206.png" alt=""></p><h4 id="运行vuepress"><a href="#运行vuepress" class="headerlink" title="运行vuepress"></a>运行vuepress</h4><p><font color="red">git命令行切换到docs目录</font>执行</p><pre class=" language-bash"><code class="language-bash">vuepress dev</code></pre><p><img src="https://chenxinshinian.oss-cn-beijing.aliyuncs.com/tupian20200123/20200127201802.png" alt=""></p><p>可以看到vuepress开启的端口（默认是8080端口，如果8080端口被占用vuepress就会自动切换到未被占用端口）<br><img src="https://chenxinshinian.oss-cn-beijing.aliyuncs.com/tupian20200123/20200127201834.png" alt=""><br>浏览器输入地址可以看到<br><img src="https://chenxinshinian.oss-cn-beijing.aliyuncs.com/tupian20200123/20200127202050.png" alt=""></p><h3 id="vuepress配置文件"><a href="#vuepress配置文件" class="headerlink" title="vuepress配置文件"></a>vuepress配置文件</h3><p>在docs文件夹下执行</p><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 在docs文档目录下创建一个 .vuepress 目录，所有 VuePress 相关的文件都将会被放在这里</span><span class="token function">mkdir</span> .vuepress<span class="token comment" spellcheck="true"># 进入 .vuepress 文件夹</span><span class="token function">cd</span> .vuepress/<span class="token comment" spellcheck="true"># 创建 VuePress 网站配置文件 </span><span class="token function">touch</span> config.js<span class="token comment" spellcheck="true"># 切换到blog根目录执行</span><span class="token function">cd</span> <span class="token punctuation">..</span>/<span class="token punctuation">..</span><span class="token comment" spellcheck="true"># 执行初始化目录</span><span class="token function">npm</span> init -y</code></pre><p>此时项目结构应该是:</p><pre><code>.├─ docs│  ├─ README.md│  └─ .vuepress│     └─ config.js└─ package.json</code></pre><p>打开config.js文件夹<br>将下面代码粘贴进去</p><pre class=" language-js"><code class="language-js">module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">{</span>  title<span class="token punctuation">:</span> <span class="token string">'Hello VuePress'</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true">// 标题</span>  description<span class="token punctuation">:</span> <span class="token string">'Just playing around'</span> <span class="token comment" spellcheck="true">// 描述</span><span class="token punctuation">}</span></code></pre><p><img src="https://chenxinshinian.oss-cn-beijing.aliyuncs.com/tupian20200123/20200127204810.png" alt=""></p><h4 id="运行vuepress看看效果"><a href="#运行vuepress看看效果" class="headerlink" title="运行vuepress看看效果"></a>运行vuepress看看效果</h4><p>切换到docs目录下<br>执行</p><pre class=" language-bash"><code class="language-bash">vuepress dev</code></pre><p><img src="https://chenxinshinian.oss-cn-beijing.aliyuncs.com/tupian20200123/20200127205044.png" alt=""></p><h3 id="配置首页"><a href="#配置首页" class="headerlink" title="配置首页"></a>配置首页</h3><p>打开docs目录下的README.md文件<br><img src="https://chenxinshinian.oss-cn-beijing.aliyuncs.com/tupian20200123/20200127205731.png" alt=""><br>将以下内容粘贴进去</p><pre class=" language-yaml"><code class="language-yaml"><span class="token punctuation">---</span><span class="token key atrule">home</span><span class="token punctuation">:</span> <span class="token boolean important">true</span><span class="token key atrule">heroImage</span><span class="token punctuation">:</span> /hero.png<span class="token key atrule">heroText</span><span class="token punctuation">:</span> Hero 标题<span class="token key atrule">tagline</span><span class="token punctuation">:</span> Hero 副标题<span class="token key atrule">actionText</span><span class="token punctuation">:</span> 快速上手 →<span class="token key atrule">actionLink</span><span class="token punctuation">:</span> /zh/guide/<span class="token key atrule">features</span><span class="token punctuation">:</span><span class="token punctuation">-</span> <span class="token key atrule">title</span><span class="token punctuation">:</span> 简洁至上  <span class="token key atrule">details</span><span class="token punctuation">:</span> 以 Markdown 为中心的项目结构，以最少的配置帮助你专注于写作。<span class="token punctuation">-</span> <span class="token key atrule">title</span><span class="token punctuation">:</span> Vue驱动  <span class="token key atrule">details</span><span class="token punctuation">:</span> 享受 Vue + webpack 的开发体验，在 Markdown 中使用 Vue 组件，同时可以使用 Vue 来开发自定义主题。<span class="token punctuation">-</span> <span class="token key atrule">title</span><span class="token punctuation">:</span> 高性能  <span class="token key atrule">details</span><span class="token punctuation">:</span> VuePress 为每个页面预渲染生成静态的 HTML，同时在页面被加载的时候，将作为 SPA 运行。<span class="token key atrule">footer</span><span class="token punctuation">:</span> MIT Licensed <span class="token punctuation">|</span> Copyright © 2018<span class="token punctuation">-</span>present Evan You<span class="token punctuation">---</span></code></pre><p>在运行vuepress将看到以下效果<br><img src="https://chenxinshinian.oss-cn-beijing.aliyuncs.com/tupian20200123/20200127210245.png" alt=""></p><h4 id="了解markdown"><a href="#了解markdown" class="headerlink" title="了解markdown"></a>了解markdown</h4><p>这里你需要了解以下<a href="https://vuepress.vuejs.org/zh/guide/markdown.html#header-anchors" target="_blank" rel="noopener">markdown扩展</a></p><h3 id="首页图片和favicon-png图片"><a href="#首页图片和favicon-png图片" class="headerlink" title="首页图片和favicon.png图片"></a>首页图片和favicon.png图片</h3><p>进入 .vuepress目录下新建public文件夹<br><img src="https://chenxinshinian.oss-cn-beijing.aliyuncs.com/tupian20200123/20200127211950.png" alt=""><br>将准备好的两个图标放到public文件夹下面（你可以到<a href="https://www.easyicon.net/" target="_blank" rel="noopener">easyicon</a>找自己喜欢的图标）<br><img src="https://chenxinshinian.oss-cn-beijing.aliyuncs.com/tupian20200123/20200127212315.png" alt=""></p><p>修改docs下面REDEME.md文件<br><img src="https://chenxinshinian.oss-cn-beijing.aliyuncs.com/tupian20200123/20200127212442.png" alt=""></p><p>修改config.js文件</p><pre class=" language-js"><code class="language-js">head<span class="token punctuation">:</span> <span class="token punctuation">[</span>    <span class="token punctuation">[</span><span class="token string">'link'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span> rel<span class="token punctuation">:</span> <span class="token string">'icon'</span><span class="token punctuation">,</span> href<span class="token punctuation">:</span> <span class="token string">'/logo.png'</span> <span class="token punctuation">}</span><span class="token punctuation">]</span>  <span class="token punctuation">]</span></code></pre><p><img src="https://chenxinshinian.oss-cn-beijing.aliyuncs.com/tupian20200123/20200127212839.png" alt=""></p><p>重新运行vuepress查看效果<br><img src="https://chenxinshinian.oss-cn-beijing.aliyuncs.com/tupian20200123/20200127213033.png" alt=""></p><h3 id="导航配置"><a href="#导航配置" class="headerlink" title="导航配置"></a>导航配置</h3><p>在config.js 中增加以下代码</p><pre class=" language-js"><code class="language-js">themeConfig<span class="token punctuation">:</span> <span class="token punctuation">{</span>    sidebarDepth<span class="token punctuation">:</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true">//最大嵌套深度</span>    lastUpdated<span class="token punctuation">:</span> <span class="token string">'Last Updated'</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true">//显示最后更新时间</span>    nav<span class="token punctuation">:</span> <span class="token punctuation">[</span>      <span class="token comment" spellcheck="true">//单个导航</span>      <span class="token punctuation">{</span> text<span class="token punctuation">:</span> <span class="token string">'首页'</span><span class="token punctuation">,</span> link<span class="token punctuation">:</span> <span class="token string">'/'</span> <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true">//内部跳转</span>      <span class="token punctuation">{</span> text<span class="token punctuation">:</span> <span class="token string">'关于'</span><span class="token punctuation">,</span> link<span class="token punctuation">:</span> <span class="token string">'/about/'</span> <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true">//关于页面</span>      <span class="token punctuation">{</span> text<span class="token punctuation">:</span> <span class="token string">'GitHub'</span><span class="token punctuation">,</span> link<span class="token punctuation">:</span> <span class="token string">'https://github.com/chenxinshinian'</span> <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true">//外部跳转</span>      <span class="token punctuation">{</span>       <span class="token comment" spellcheck="true">//下拉列表</span>        text<span class="token punctuation">:</span> <span class="token string">'语言'</span><span class="token punctuation">,</span>        items<span class="token punctuation">:</span> <span class="token punctuation">[</span>          <span class="token punctuation">{</span> text<span class="token punctuation">:</span> <span class="token string">'chinese'</span><span class="token punctuation">,</span> link<span class="token punctuation">:</span> <span class="token string">'/language/chinese/'</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>          <span class="token punctuation">{</span> text<span class="token punctuation">:</span> <span class="token string">'japanese'</span><span class="token punctuation">,</span> link<span class="token punctuation">:</span> <span class="token string">'/language/japanese/'</span> <span class="token punctuation">}</span>        <span class="token punctuation">]</span>      <span class="token punctuation">}</span><span class="token punctuation">,</span>      <span class="token comment" spellcheck="true">// 下拉列表显示分组</span>      <span class="token punctuation">{</span>        text<span class="token punctuation">:</span> <span class="token string">'分享'</span><span class="token punctuation">,</span>        items<span class="token punctuation">:</span> <span class="token punctuation">[</span>        <span class="token punctuation">{</span>             text<span class="token punctuation">:</span> <span class="token string">'索引'</span><span class="token punctuation">,</span>             items<span class="token punctuation">:</span> <span class="token punctuation">[</span>            <span class="token punctuation">{</span> text<span class="token punctuation">:</span> <span class="token string">'Java'</span><span class="token punctuation">,</span> link<span class="token punctuation">:</span> <span class="token string">'/Java/'</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>            <span class="token punctuation">{</span> text<span class="token punctuation">:</span> <span class="token string">'JavaScript'</span><span class="token punctuation">,</span> link<span class="token punctuation">:</span> <span class="token string">'/JavaScript/'</span> <span class="token punctuation">}</span>            <span class="token punctuation">]</span>         <span class="token punctuation">}</span>        <span class="token punctuation">]</span>      <span class="token punctuation">}</span>    <span class="token punctuation">]</span><span class="token punctuation">,</span>       sidebar<span class="token punctuation">:</span> <span class="token punctuation">{</span>      <span class="token string">'/Java/'</span><span class="token punctuation">:</span> <span class="token punctuation">[</span>             <span class="token string">''</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true">// 代表/Java/</span>          <span class="token string">'java1'</span><span class="token punctuation">,</span>           <span class="token string">'java2'</span>      <span class="token punctuation">]</span><span class="token punctuation">,</span>      <span class="token string">'/JavaScript/'</span><span class="token punctuation">:</span> <span class="token punctuation">[</span>           <span class="token string">''</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true">// 代表 /JavaScript/</span>        <span class="token string">'js1'</span>     <span class="token punctuation">]</span>  <span class="token punctuation">}</span>  <span class="token punctuation">}</span></code></pre><p><img src="https://chenxinshinian.oss-cn-beijing.aliyuncs.com/tupian20200123/20200127224625.png" alt=""></p><p>运行vuepress后应该出现效果:<br><img src="https://chenxinshinian.oss-cn-beijing.aliyuncs.com/tupian20200123/20200128182950.png" alt=""><br>这时点击导航栏应该是显示404，这是英文虽然配置了导航但是但是响应的目录还没有创建</p><p>导航配置对应的目录结构:<br><img src="https://chenxinshinian.oss-cn-beijing.aliyuncs.com/tupian20200123/20200128184319.png" alt=""><br><font color="red">注意：每个导航下面都要有一个README.md文件作为导航的首页</font></p><p>其他页面内容<br><img src="https://chenxinshinian.oss-cn-beijing.aliyuncs.com/tupian20200123/20200128185345.png" alt=""><br><img src="https://chenxinshinian.oss-cn-beijing.aliyuncs.com/tupian20200123/20200128185435.png" alt=""><br><img src="https://chenxinshinian.oss-cn-beijing.aliyuncs.com/tupian20200123/20200128185452.png" alt=""></p><p>页面效果：<br><img src="https://chenxinshinian.oss-cn-beijing.aliyuncs.com/tupian20200123/20200128185602.png" alt=""></p><p><a href="https://vuepress.vuejs.org/zh/theme/default-theme-config.html" target="_blank" rel="noopener">更多详细配置</a></p><h3 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h3><p>教程部署在github pages上面<br>登录<a href="https://github.com/" target="_blank" rel="noopener">github</a>创建一个仓库<br><img src="https://chenxinshinian.oss-cn-beijing.aliyuncs.com/tupian20200123/20200128193725.png" alt=""><br><img src="https://chenxinshinian.oss-cn-beijing.aliyuncs.com/tupian20200123/20200128193949.png" alt=""></p><p>格式为<code>&lt;username&gt;.github.io</code><br>最后点击最小面的绿色按钮创建</p><p>github的操作就结束了<br>接下来正在你的网站根目录创建<br>deploy.sh文件,将下面的内容粘贴进去<br><img src="https://chenxinshinian.oss-cn-beijing.aliyuncs.com/tupian20200123/20200128201345.png" alt=""></p><pre class=" language-yaml"><code class="language-yaml"><span class="token comment" spellcheck="true">#!/usr/bin/env sh</span><span class="token comment" spellcheck="true"># 确保脚本抛出遇到的错误</span>set <span class="token punctuation">-</span>e<span class="token comment" spellcheck="true"># 生成静态文件</span>npm run docs<span class="token punctuation">:</span>build<span class="token comment" spellcheck="true"># 进入生成的文件夹</span>cd docs/.vuepress/dist<span class="token comment" spellcheck="true"># 如果是发布到自定义域名</span><span class="token comment" spellcheck="true"># echo 'www.example.com' > CNAME</span>git initgit add <span class="token punctuation">-</span>Agit commit <span class="token punctuation">-</span>m 'deploy'<span class="token comment" spellcheck="true"># 如果发布到 https://&lt;USERNAME>.github.io</span> git push <span class="token punctuation">-</span>f git@github.com<span class="token punctuation">:</span>&lt;USERNAME<span class="token punctuation">></span>/&lt;USERNAME<span class="token punctuation">></span>.github.io.git master<span class="token comment" spellcheck="true"># 如果发布到 https://&lt;USERNAME>.github.io/&lt;REPO></span><span class="token comment" spellcheck="true"># git push -f git@github.com:&lt;USERNAME>/&lt;REPO>.git master:gh-pages</span>cd <span class="token punctuation">-</span></code></pre><p><img src="https://chenxinshinian.oss-cn-beijing.aliyuncs.com/tupian20200123/20200128194623.png" alt=""></p><p>保存后双击运行deploy.sh文件<br>然后 浏览器输入<br><img src="https://chenxinshinian.oss-cn-beijing.aliyuncs.com/tupian20200123/20200128194746.png" alt=""><br>你就部署成功了</p><h3 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h3><h4 id="增加返回顶部效果"><a href="#增加返回顶部效果" class="headerlink" title="增加返回顶部效果"></a>增加返回顶部效果</h4><p><img src="https://chenxinshinian.oss-cn-beijing.aliyuncs.com/tupian20200123/20200128194852.png" alt=""><br>步骤过于简单根据<a href="https://vuepress.vuejs.org/zh/plugin/official/plugin-back-to-top.html" target="_blank" rel="noopener">官方提示</a>安装插件就可以了</p><h4 id="添加评论功能"><a href="#添加评论功能" class="headerlink" title="添加评论功能"></a>添加评论功能</h4><h5 id="安装valine"><a href="#安装valine" class="headerlink" title="安装valine"></a>安装valine</h5><p>在blog目录下打开git命令窗口，依次执行下面两条命令</p><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># Install leancloud's js-sdk</span><span class="token function">npm</span> <span class="token function">install</span> leancloud-storage --save<span class="token comment" spellcheck="true"># Install valine</span><span class="token function">npm</span> <span class="token function">install</span> valine --save</code></pre><p>接下来在.vuepress文件夹下创建components文件夹，再到components文件夹下面创建Valine.vue文件</p><p>打开Valine.vue文件将下面内容粘贴进去</p><pre class=" language-js"><code class="language-js"><span class="token operator">&lt;</span>template<span class="token operator">></span>  <span class="token operator">&lt;</span>div id<span class="token operator">=</span><span class="token string">"vcomments"</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>template<span class="token operator">></span><span class="token operator">&lt;</span>script<span class="token operator">></span><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>  name<span class="token punctuation">:</span> <span class="token string">'Valine'</span><span class="token punctuation">,</span>  mounted<span class="token punctuation">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// require window </span>    <span class="token keyword">const</span> Valine <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'valine'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> window <span class="token operator">!==</span> <span class="token string">'undefined'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">this</span><span class="token punctuation">.</span>window <span class="token operator">=</span> window      window<span class="token punctuation">.</span>AV <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'leancloud-storage'</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span>    <span class="token keyword">new</span> <span class="token class-name">Valine</span><span class="token punctuation">(</span><span class="token punctuation">{</span>      el<span class="token punctuation">:</span> <span class="token string">'#vcomments'</span> <span class="token punctuation">,</span>      appId<span class="token punctuation">:</span> <span class="token string">''</span><span class="token punctuation">,</span><span class="token comment" spellcheck="true">// 这里填你的appId</span>      appKey<span class="token punctuation">:</span> <span class="token string">''</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true">// 这里填你的appKey</span>      notify<span class="token punctuation">:</span><span class="token boolean">false</span><span class="token punctuation">,</span>       verify<span class="token punctuation">:</span><span class="token boolean">false</span><span class="token punctuation">,</span>       avatar<span class="token punctuation">:</span><span class="token string">'mm'</span><span class="token punctuation">,</span>       placeholder<span class="token punctuation">:</span> <span class="token string">'说点什么...'</span>     <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">}</span><span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">></span></code></pre><p>接下来登录或者在注册<a href="https://www.leancloud.cn/" target="_blank" rel="noopener">leancloud</a><br>之后进入控制台，点击左下角创建应用<br><img src="https://chenxinshinian.oss-cn-beijing.aliyuncs.com/tupian20200123/20200128200204.png" alt=""><br>应用创建好以后，进入刚刚创建的应用，选择左下角的设置&gt;应用Key，然后就能看到你的APP ID和APP Key了：<br><img src="https://chenxinshinian.oss-cn-beijing.aliyuncs.com/tupian20200123/20200128200338.png" alt=""></p><p>添加你的域名<br><img src="https://chenxinshinian.oss-cn-beijing.aliyuncs.com/tupian20200123/20200128200722.png" alt=""></p><p>将你的app id 和app key粘贴到Valine.vue文件里的对应位置<br><img src="https://chenxinshinian.oss-cn-beijing.aliyuncs.com/tupian20200123/20200128200456.png" alt=""></p><p>然后在你想加入评论的页面加上</p><p><code>&lt;Valine&gt;&lt;/Valine&gt;</code></p><p>如我在首页README.md文件中添加<br><img src="https://chenxinshinian.oss-cn-beijing.aliyuncs.com/tupian20200123/20200128200633.png" alt=""></p><p>然后双击deploy.sh文件，将他部署到github</p><p>效果<br><img src="https://chenxinshinian.oss-cn-beijing.aliyuncs.com/tupian20200123/20200128201034.png" alt=""></p><p><font color="red">如果没有效果请清楚浏览器缓存或者更换浏览器访问</font></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 分享 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vuepress </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
